###### skip list

跳表是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树

(1) 由很多层结构组成，level是通过一定的概率随机产生的。
(2) 每一层都是一个有序的链表，默认是升序
(3) 最底层(Level 1)的链表包含所有元素。
(4) 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。
(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

数据结构

```c
// node 保存节点信息，forward数组保存，不同层数后继节点
typedef  struct nodeStructure  
{  
    int key;  
    int value;  
    struct nodeStructure *forward[1];
}nodeStructure; 

// 跳表结构，level表示跳表的层数，header指向最高层的节点
typedef  struct skiplist  
{  
    int level;  
    nodeStructure *header;  
}skiplist;  

// 随机生成该节点所占的层数
int randomLevel()  
{
    int k=1;
    while (rand()%2)  
        k++;  
    k=(k<MAX_LEVEL)?k:MAX_LEVEL;
    return k;  
}

// 初始化跳表，初始化header节点的数据，主要是header forward指向null
// 搜索节点，外层循环是 层数，内层循环是 单链，如果在高层没有找到，转入下层
// 插入节点（随机生成该节点所占的层数，随机0.5的概率），删除节点，先找到比插入删除节点小的最大节点，后面的操作跟平常插入节点一致，特别注意删除或插入顶层链表中的元素所引起的，跳表层数变化
```

###### 排序

归并排序

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

使用归并排序时，应该尽量使用非递归方法

经验上讲，归并排序的效率要低于随机化的快速排序，数据量越大，差异越明显。归并排序后期合并的操作所花费的时间随着数据量增大而增加。

一般情况下，用归并是最好的，其他的排序算法都是建立在一定或者某种特殊的条件下才能表现出较好的性能，比如说快速排序，在数据相对无序的情况下，性能较好，插入排序在数据相对有序的情况下较好

归并排序可以优化的地方，不回写，

###### 参考

- [跳跃表的实现与原理](http://dsqiu.iteye.com/blog/1705530)
- [geekforgeek 归并排序](http://www.geeksforgeeks.org/iterative-merge-sort/)