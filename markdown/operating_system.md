###### 进程

进程状态转换

![state_transition](/Users/tamchen/Documents/project/material/state_transition.jpg)

引起进程切换的因素有 `中断`、`陷阱`、`系统调用`

中断包括有时钟中断、I/O中断、内存失效

进程切换的完整步骤

1）保存处理器上下文环境，包括程序计数器和其他寄存器。

2）更新当前处于运行态进程的进程控制块，包括将进程的状态改变到另一状态（就绪态、阻塞态、就绪/挂起态或退出态）。还必须更新其他相关域，包括离开运行态的原因和记账信息。

3）将进程的进程控制块移到相应的队列（就绪、在事件i 处阻塞、就绪/挂起）。

4）选择另一个进程执行，这方面的内容将在本书的第四部分探讨。

5）更新所选择进程的进程控制块，包括将进程的状态变为运行态。

6）更新内存管理的数据结构，这取决于如何管理地址转换，这方面的内容将在第三部分探讨。

7）恢复处理器在被选择的进程最近一次切换出运行状态时的上下文环境，这可以通过载入程序计数器和其他寄存器以前的值来实现。

进程间通信方式

- 管道（pipe）,流管道(s_pipe)和命名管道（FIFO）（前两者只允许在具有亲缘关系的进程中通信，而命名管道则无此要求）
- 信号量（signal）（信号量是一个计数器，可以用来控制多个进程对共享资源的访问。作为进程间以及同一进程内不同线程之间的同步手段）
- 消息队列（消息队列是由消息的链表，存放在内核中并由消息队列标识符标识）
- 共享内存（共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，例如IPC方式）
- 信号（用于通知接收进程某个事件已经发生，作为进程间以及同一进程不同线程之间的同步手段）
- 套接字（socket)（与其他通信机制不同的是，它可用于不同机器间的进程通信）

用户态与内核态

用户态与内核态的最大不同在于特权级的不 同，即权力的不同，通常来说3级上被称为用户态，而0级则成为内核态，当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系 统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。

用户态切换到内核态的几种方式

- 系统调用
- 异常
- 外围设备的中断

进程内核栈、用户栈

内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。

死锁

死锁成立的四个条件 互斥条件、不可抢占条件、请求与保持条件、循环等待条件

进程调度算法

- 先来先服务（FCFS）调度算法
- 短作业优先（SJF）调度算法
- 时间片轮转（RR）调度算法
- 高响应比优先（Highest Response Ratio First，HRRF）调度算法
- 多级反馈队列（Multi-Level Feedback Queue）调度算法
- 最高优先级优先调度算法



操作系统的四个特性

并发、共享、虚拟、异步

（1）以多进程形式，允许多个任务同时运行；

（2）以多线程形式，允许单个任务分成不同的部分运行；

（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。